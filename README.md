# Hotwire: Dynamic forms with Stimulus

[![Deploy to Heroku](https://www.herokucdn.com/deploy/button.png)][heroku-deploy-app]

[heroku-deploy-app]: https://heroku.com/deploy?template=https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-stimulus-dynamic-forms

Interactivity is a core selling points for client-side rendering frameworks.
Those frameworks' value propositions are most compelling when they emphasize
their ability to change a page's shape and content in response to an end-users
actions.

Imagine a page that categorizes a record into a pre-determined set of groups,
where being categorizes into one group means that the record needs some
additional information. For example, imagine drafting a shared Document with
various levels of access. Users mark a Document as "publish" when they feel it's
ready to be shared publicly, "draft" when it's not quite ready to be published,
and "passcode protected" when it's ready only to be shared with someone who
knows the passcode.

Providing a "passcode" value shouldn't be required when marking a Document with
"publish"- or "draft"-level access, while marking a Document with "passcode
protect" access without a "passcode" would be invalid.

If we built this page with a client-side rendering framework, we could store the
selected level of access in-memory within the JavaScript process, and use that
value to determine whether or not to render the "passcode" fields. In response
to changes to the access level, client-side frameworks would re-render portions
of the page _within the current browser session_.

Unfortunately, server-side rendering frameworks don't have that luxury. The
server renders the page once, and only once, when responding to an HTTP request.
If we built this page with a server-side rendering framework, how might we meet
bake-in a similar level of interactivity?

## Progressively enhancing server-generated HTML

To start, we'll establish a baseline that renders HTML retrieved over HTTP
without any JavaScript. The server will render _all combinations_ for the form's
fields, including the field to collect the "passcode".

Once we've established a foundation, we'll progressively enhancement the form's
interactivity to enable the "passcode" field when "passcode protected" is
selected, and disable and hide it otherwise. This version will use full-page
navigations and round-trips to the server to fetch updated HTML, and will work
even when JavaScript is disabled.

Finally, we'll incrementally improve the experience through JavaScript that
controls the "passcode" field without any client-server communication.

The code samples shared in this article omit the majority of the applicationâ€™s
setup. The application's code was generated by executing `rails new`. The rest
of the [source code][] from this article can be found on GitHub, and is best
read [commit-by-commit][].

[source code]: https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-stimulus-dynamic-forms
[commit-by-commit]: https://github.com/thoughtbot/hotwire-example-template/compare/hotwire-example-stimulus-dynamic-forms

## Our starting point

Our application declares a `Document` backed by [Active Record][]. In addition
to validations, the `Document` class defines an [enumeration][] to outline the
possible levels of access and accepts [Action Text][] content:

```ruby
class Document < ApplicationRecord
  enum :access, publish: 0, draft: 1, passcode_protected: 2

  has_rich_text :content

  with_options presence: true do
    validates :content
    validates :passcode, if: :passcode_protected?
  end
end
```

[Active Record]: https://guides.rubyonrails.org/active_record_basics.html
[Action Text]: https://edgeguides.rubyonrails.org/action_text_overview.html
[enumeration]: https://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html

`Document` records are managed by a conventional `DocumentsController` class:

```ruby
# app/controllers/documents_controller.rb

class DocumentsController < ApplicationController
  def new
    @document = Document.new
  end

  def create
    @document = Document.new document_params

    if @document.save
      redirect_to document_url(@document)
    else
      render :new, status: :unprocessable_entity
    end
  end

  def show
    @document = Document.find params[:id]
  end

  private

  def document_params
    params.require(:document).permit(
      :access,
      :passcode,
      :content,
    )
  end
end
```

The `documents/new` template collects the access level through a [group][] of
[`<input type="radio">`][radio] elements, the content through an Action
Text-powered [`<trix-editor>`][trix] element, and submits the [`<form>`][form]
element as a `POST` request to the `DocumentsController#create` action:

[group]: https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html#method-i-collection_radio_buttons
[trix]: https://trix-editor.org
[radio]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/radio
[form]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form

```erb
<%# app/views/documents/new.html.erb %>

<section class="w-full max-w-lg">
  <h1>New document</h1>

  <%= form_with model: @document do |form| %>
    <%= render partial: "errors", object: @document.errors %>

    <%= field_set_tag "Access" do %>
      <%= form.collection_radio_buttons :access, Document.accesses.keys, :to_s, :humanize do |builder| %>
        <span>
          <%= builder.radio_button %>
          <%= builder.label %>
        </span>
      <% end %>
    <% end %>

    <%= field_set_tag "Passcode protected" do %>
      <%= form.label :passcode %>
      <%= form.text_field :passcode %>
    <% end %>

    <%= form.label :content %>
    <%= form.rich_text_area :content %>

    <%= form.button %>
  <% end %>
</section>
```

![A form collecting information about a Document, including its access level and content](https://user-images.githubusercontent.com/2575027/150657727-09919557-322c-4697-b529-0703b418c470.png)

When the submission's data is invalid the controller responds with a [422
Unprocessable Entity][422] re-renders the `app/views/documents/new.html.erb`
template to include the `app/views/application/_errors.html.erb` partial. That
partial's [source code](./app/views/application/_errors.html.erb) is omitted
here, but it's very similar to [Rails' scaffolds for new models][scaffolds]:

[422]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422
[scaffolds]: https://github.com/rails/rails/blob/984c3ef2775781d47efa9f541ce570daa2434a80/railties/lib/rails/generators/erb/scaffold/templates/_form.html.erb.tt#L2-L12

![Validation error messages rendered above the form's fields](https://user-images.githubusercontent.com/2575027/150657724-98d59bc0-4eda-4f75-bc83-3e2f587e3ec8.png)

When the submission is valid, the record is created, the data is written to the
database, and the controller serves an [HTTP redirect response][redirect] to the
`documents#show` route.

[redirect]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections

## Dynamic form fields without JavaScript

Our starting point serves as a solid, reliable, and robust foundation. The
"moving parts" are kept to a minimum. The form collects information with or
without the presence of a JavaScript-capable browsing environment.

However, always rendering the "passcode" field, regardless of the currently
selected "access" level isn't interactive, and could lead to a confusing
end-user experience. To improve on that experience, we'll need to introduce a
mechanism that hides and ignores any "passcode" values when the Document is has
"publish" or "draft" access.

We can use the `<fieldset>` element's [disabled][fieldset-disabled] attribute to
control whether or not its descendant fields are encoded into the request and
transmitted to the server when the `<form>` is submitted.

The `[disabled]` attribute is a [boolean attribute][], so its presence alone is
enough to omit the element and its descendants. We'll base the presence or
absence on whether or not the `Document` record's "access" level is "passcode
protect":

```diff
--- a/app/views/documents/new.html.erb
+++ b/app/views/documents/new.html.erb
-    <%= field_set_tag "Passcode protected" do %>
+    <%= field_set_tag "Passcode protect", disabled: !@document.passcode_protect? do %>
       <%= form.label :passcode %>
       <%= form.text_field :passcode %>
     <% end %>
```

Encoding the `[disabled]` attribute into the HTML affords an opportunity to
apply specific styles to the `<fieldset>` when it matches the [:disabled][]
pseudo-class. For example, when the `<fieldset>` is disabled, apply the
[display: none][] rule:

```diff
-    <%= field_set_tag "Passcode protect", disabled: !@document.passcode_protect? do %>
+    <%= field_set_tag "Passcode protect", disabled: !@document.passcode_protect?, class: "disabled:hidden" do %>
       <%= form.label :passcode %>
       <%= form.text_field :passcode %>
     <% end %>
```

[fieldset-disabled]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset#attr-disabled
[boolean attribute]: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes#boolean_attributes
[:disabled]: https://developer.mozilla.org/en-US/docs/Web/CSS/:disabled
[display: none]: https://developer.mozilla.org/en-US/docs/Web/CSS/display#box

Since our servers are responsible for rendering the page's HTML, rendering HTML
in response to a client-side change to the "access" level requires communicating
with the server. How might we fetch and render new HTML from the server without
using [XMLHttpRequest][], [fetch][], or any JavaScript at all?

[XMLHttpRequest]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API

### Fetching remote data without JavaScript

Browsers provide a built-in mechanism to submit HTTP requests without JavaScript
code: `<form>` elements. By clicking `<button>` and `<input type="submit">`
elements, end-users submit `<form>` elements and issue HTTP requests. What's
more, those `<button>` elements are capable of overriding _where_ and _how_ that
`<form>` element transmits its submission by through their [formmethod][] and
[formaction][] attributes.

We'll change pair "Access" group of `<input type="radio">` elements with a
"Select access" button keep the page's HTML and the current selection in-sync:

```diff
--- a/app/views/documents/new.html.erb
+++ b/app/views/documents/new.html.erb
     <%= field_set_tag "Access" do %>
       <%= form.collection_radio_buttons :access, Document.accesses.keys, :to_s, :humanize do |builder| %>
         <span>
           <%= builder.radio_button %>
           <%= builder.label %>
         </span>
       <% end %>
+      <button formmethod="get" formaction="<%= new_document_path %>">Select access</button>
     <% end %>
```

The `<button>` element's `[formmethod="get"]` attribute directs the `<form>` to
submit as an [HTTP GET][] request and the `[formaction="/documents/new"]`
attribute directs the `<form>` to submit to the `/documents/new` path. This
verb-path pairing might seem familiar: it's the same request our browser will
make when we visit the current page.

Submitting `<form>` as a `GET` request encodes all the fields' values into [URL
parameters][]. We can read those values in the `documents#new` action whenever
they're provided, and use them when rendering the `<form>` element and its
fields:

```diff
--- a/app/controllers/documents_controller.rb
+++ b/app/controllers/documents_controller.rb
 class DocumentsController < ApplicationController
   def new
-    @document = Document.new
+    @document = Document.new document_params
   end

   def create
@@ -20,7 +20,7 @@ class DocumentsController < ApplicationController
   private

   def document_params
-    params.require(:document).permit(
+    params.fetch(:document, {}).permit(
       :access,
       :passcode,
       :content,
```

While rendering the `documents#new` template, the controller will determine the
presence or absence of the attribute based on whether or not an "access" level
is encoded into the request's URL parameters used to construct the `Document`
instance.

https://user-images.githubusercontent.com/2575027/150658326-72a0a8e6-c131-41c6-a364-e049d6f7f982.mov

Submitting the form's values as query parameters comes with two caveats:

1.  Any selected `<input type="file">` values will be discarded

2.  according to the [HTTP specification][], there are no limits on the length of
    a URI:

    > The HTTP protocol does not place any a priori limit on the length of
    > a URI. Servers MUST be able to handle the URI of any resource they
    > serve, and SHOULD be able to handle URIs of unbounded length if they
    > provide GET-based forms that could generate such URIs.
    >
    > - 3.2.1 General Syntax

    Unfortunately, in practice, [conventional wisdom][] suggests that URLs over
    2,000 characters are risky.

In the case of our simple example `<form>`, neither points pose any risk.

[HTTP specification]: https://tools.ietf.org/html/rfc2616#section-3.2.1
[conventional wisdom]: https://stackoverflow.com/a/417184
[URL parameters]: https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_URL#parameters
[formmethod]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-formmethod
[formaction]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-formaction
[HTTP GET]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET

Finally, it's important to render the `<input type="radio">` elements with
[autocomplete="off"][] so that browser-initiated optimizations don't introduce
inconsistencies between the initial client-side selection and the
server-rendered selection:

```diff
--- a/app/views/documents/new.html.erb
+++ b/app/views/documents/new.html.erb
     <%= field_set_tag "Access" do %>
       <%= form.collection_radio_buttons :access, Document.accesses.keys, :to_s, :humanize do |builder| %>
         <span>
-          <%= builder.radio_button %>
+          <%= builder.radio_button autocomplete: "off" %>
           <%= builder.label %>
         </span>
       <% end %>
       <button formmethod="get" formaction="<%= new_document_path %>">Select access</button>
     <% end %>
```

[autocomplete="off"]: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values

## Dynamic form fields with JavaScript

Now that we've made some JavaScript-free improvements, there are opportunities
to [progressively enhance][] the experience further. We can toggle the
`[disabled]` attribute of the "Access" `<fieldset>` element locally, without any
communication with the server.

First, we'll want to continue to support our JavaScript-free behavior, so we'll
nest the `<button formmethod="get">` within a [`<noscript>` element][noscript].
Descendants of `<noscript>` elements are present JavaScript is unavailable to
the browser, and ignored otherwise:

[noscript]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript

```diff
--- a/app/views/documents/new.html.erb
+++ b/app/views/documents/new.html.erb
       <%= form.collection_radio_buttons :access, Document.accesses.keys, :to_s, :humanize do |builder| %>
         <span>
           <%= builder.radio_button autocomplete: "off" %>
           <%= builder.label %>
         </span>
       <% end %>

+      <noscript>
         <button formmethod="get" formaction="<%= new_document_path %>">Select access</button>
+      </noscript>
     <% end %>
```

We'll create our application's first [Stimulus Controller][] to [progressively
enhance][] the experience. The controller will use `fields` as its
[identifier][]. We'll modify our `<form>` element so that it declares the
`[data-controller]` attribute with the `fields` token:

[progressively enhance]: https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement
[Stimulus Controller]: https://stimulus.hotwired.dev/handbook/hello-stimulus#controllers-bring-html-to-life
[identifier]: https://stimulus.hotwired.dev/reference/controllers#identifiers

```diff
--- a/app/views/documents/new.html.erb
+++ b/app/views/documents/new.html.erb
-  <%= form_with model: @document do |form| %>
+  <%= form_with model: @document, data: { controller: "fields" } do |form| %>
     <%= render partial: "errors", object: @document.errors %>

     <%= field_set_tag "Access" do %>
```

To listen for changes in selection, we'll route [input][] events to our `fields`
controller by annotating each `<input type="radio">` element with the
`[data-action="input->fields#enable"]` attribute:

```diff
--- a/app/views/documents/new.html.erb
+++ b/app/views/documents/new.html.erb
     <%= field_set_tag "Access" do %>
       <%= form.collection_radio_buttons :access, Document.accesses.keys, :to_s, :humanize do |builder| %>
         <span>
-          <%= builder.radio_button autocomplete: "off" %>
+          <%= builder.radio_button autocomplete: "off",
+                                   aria: { controls: form.field_id(:access, builder.value, :fieldset) },
+                                   data: { action: "input->fields#enable" } %>
           <%= builder.label %>
         </span>
       <% end %>
     <% end %>
```

The `[data-action]` attribute's value is a [Stimulus Action][] descriptor, which
instructs Stimulus on how to respond to `input` events that fire within the
document.

[input]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event
[Stimulus Action]: https://stimulus.hotwired.dev/reference/actions

The `fields#enable` implementation reads the `<input type="radio">` element's
[name][] and [aria-controls][] attributes and finds `<fieldset>` elements with
corresponding attributes. We'll mark each `<fieldset>` with the
[disabled][fieldset-disabled], then remove the attribute for the `<fieldset>`
whose `[name]` matches the `<input type="radio">` element's `[name]`, and whose
`[id]` matches the `<input type="radio">` element's `[aria-controls]`:

[name]:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-name
[aria-controls]: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-controls

```javascript
// app/javascript/controllers/fields_controller.js

import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  enable({ target }) {
    const elements = Array.from(this.element.elements)
    const selectedElements = [ target ]

    for (const element of elements.filter(element => element.name == target.name)) {
      if (element instanceof HTMLFieldSetElement) element.disabled = true
    }

    for (const element of controlledElements(...selectedElements)) {
      if (element instanceof HTMLFieldSetElement) element.disabled = false
    }
  }
}

function controlledElements(...selectedElements) {
  return selectedElements.flatMap(selectedElement =>
    getElementsByTokens(selectedElement.getAttribute("aria-controls"))
  )
}

function getElementsByTokens(tokens) {
  const ids = (tokens ?? "").split(/\s+/)

  return ids.map(id => document.getElementById(id))
}
```

To ensure the relationship between the `<input type="radio">` elements and their
corresponding `<fieldset>` elements, we'll update our `documents/new` template
to encode those values during rendering:

```diff
--- a/app/views/documents/new.html.erb
+++ b/app/views/documents/new.html.erb
-    <%= field_set_tag "Passcode protect", disabled: !@document.passcode_protect?, class: "disabled:hidden" do %>
+    <%= field_set_tag "Passcode protect", disabled: !@document.passcode_protect?, class: "disabled:hidden",
+                                id: form.field_id(:access, :passcode_protected, :fieldset),
+                                name: form.field_name(:access) do %>
       <%= form.label :passcode %>
       <%= form.text_field :passcode %>
     <% end %>
```

https://user-images.githubusercontent.com/2575027/150658649-45b9aa1d-fe28-4a71-8772-0fb9c4502640.mov

### Supporting other form fields

While `<input type="radio">` elements are an appropriate choice for our set of
three possible choices, it's worthwhile to consider how we might handle a larger
set of choices. A natural progression might involve replacing the `<input
type="radio">` buttons with a `<select>`:

```erb
<%= field_set_tag do %>
  <%= form.label :access %>
  <%= form.select :access, {}, {}, autocomplete: "off",
                  data: { action: "change->fields#enable" } do %>
    <% Document.accesses.keys.each do |value| %>
      <%= tag.option value.humanize, value: value,
                                    aria: { controls: form.field_id(:access, value, :fieldset) } %>
    <% end %>
  <% end %>
<% end %>
```

Although our `<select>` is limited to a single choice at a time, it's possible
for a `<select>` to have multiple "selected" options. We'll want to account for
that possibility in the `fields` controller:

```diff
--- a/app/javascript/controllers/fields_controller.js
+++ b/app/javascript/controllers/fields_controller.js
@@ -2,7 +2,9 @@ import { Controller } from "@hotwired/stimulus"

 export default class extends Controller {
   enable({ target }) {
-    const selectedElements = [ target ]
+    const selectedElements = "selectedOptions" in target ?
+      target.selectedOptions :
+      [ target ]

     for (const field of this.element.elements.namedItem(target.name)) {
       if (field instanceof HTMLFieldSetElement) field.disabled = true
```

https://user-images.githubusercontent.com/2575027/150658732-bb552dc2-4f25-4f26-b33b-ca539da6ac4b.mov

## Wrapping up

We were able to progressively enhance while keeping all the details of our
requests declaratively encoded into the document's HTML.

Regardless of the situations constraints, we should start our problem solving
with the help of browsers' built-in, HTML Specification-compliant features.
