# Hotwire: Dynamic forms with Stimulus

[![Deploy to Heroku](https://www.herokucdn.com/deploy/button.png)][heroku-deploy-app]

[heroku-deploy-app]: https://heroku.com/deploy?template=https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-stimulus-dynamic-forms

Interactivity is a core selling points for client-side rendering frameworks.
Those frameworks' value propositions are most compelling when they emphasize
their ability to change a page's shape and content in response to an end-users
actions.

Imagine a page that categorizes a record into a pre-determined set of groups,
where being categorizes into one group means that the record needs some
additional information. For example, imagine drafting a shared Document with
various levels of access. Users mark a Document as "publish" when they feel it's
ready to be shared publicly, "draft" when it's not quite ready to be published,
and "passcode protected" when it's ready only to be shared with someone who
knows the passcode.

Providing a "passcode" value shouldn't be required when marking a Document with
"publish"- or "draft"-level access, while marking a Document with "passcode
protect" access without a "passcode" would be invalid.

If we built this page with a client-side rendering framework, we could store the
selected level of access in-memory within the JavaScript process, and use that
value to determine whether or not to render the "passcode" fields. In response
to changes to the access level, client-side frameworks would re-render portions
of the page _within the current browser session_.

Unfortunately, server-side rendering frameworks don't have that luxury. The
server renders the page once, and only once, when responding to an HTTP request.
If we built this page with a server-side rendering framework, how might we meet
bake-in a similar level of interactivity?

## Progressively enhancing server-generated HTML

To start, we'll establish a baseline that renders HTML retrieved over HTTP
without any JavaScript. The server will render _all combinations_ for the form's
fields, including the field to collect the "passcode".

Once we've established a foundation, we'll progressively enhancement the form's
interactivity to enable the "passcode" field when "passcode protected" is
selected, and disable and hide it otherwise. This version will use full-page
navigations and round-trips to the server to fetch updated HTML, and will work
even when JavaScript is disabled.

Finally, we'll incrementally improve the experience through JavaScript that
controls the "passcode" field without any client-server communication.

The code samples shared in this article omit the majority of the applicationâ€™s
setup. The application's code was generated by executing `rails new`. The rest
of the [source code][] from this article can be found on GitHub, and is best
read [commit-by-commit][].

[source code]: https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-stimulus-dynamic-forms
[commit-by-commit]: https://github.com/thoughtbot/hotwire-example-template/compare/hotwire-example-stimulus-dynamic-forms

## Our starting point

Our application declares a `Document` backed by [Active Record][]. In addition
to validations, the `Document` class defines an [enumeration][] to outline the
possible levels of access and accepts [Action Text][] content:

```ruby
class Document < ApplicationRecord
  enum :access, publish: 0, draft: 1, passcode_protected: 2

  has_rich_text :content

  with_options presence: true do
    validates :content
    validates :passcode, if: :passcode_protected?
  end
end
```

[Active Record]: https://guides.rubyonrails.org/active_record_basics.html
[Action Text]: https://edgeguides.rubyonrails.org/action_text_overview.html
[enumeration]: https://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html

`Document` records are managed by a conventional `DocumentsController` class:

```ruby
# app/controllers/documents_controller.rb

class DocumentsController < ApplicationController
  def new
    @document = Document.new
  end

  def create
    @document = Document.new document_params

    if @document.save
      redirect_to document_url(@document)
    else
      render :new, status: :unprocessable_entity
    end
  end

  def show
    @document = Document.find params[:id]
  end

  private

  def document_params
    params.require(:document).permit(
      :access,
      :passcode,
      :content,
    )
  end
end
```

The `documents/new` template collects the access level through a [group][] of
[`<input type="radio">`][radio] elements, the content through an Action
Text-powered [`<trix-editor>`][trix] element, and submits the [`<form>`][form]
element as a `POST` request to the `DocumentsController#create` action:

[group]: https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html#method-i-collection_radio_buttons
[trix]: https://trix-editor.org
[radio]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/radio
[form]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form

```erb
<%# app/views/documents/new.html.erb %>

<section class="w-full max-w-lg">
  <h1>New document</h1>

  <%= form_with model: @document do |form| %>
    <%= render partial: "errors", object: @document.errors %>

    <%= field_set_tag "Access" do %>
      <%= form.collection_radio_buttons :access, Document.accesses.keys, :to_s, :humanize do |builder| %>
        <span>
          <%= builder.radio_button %>
          <%= builder.label %>
        </span>
      <% end %>
    <% end %>

    <%= field_set_tag "Passcode protected" do %>
      <%= form.label :passcode %>
      <%= form.text_field :passcode %>
    <% end %>

    <%= form.label :content %>
    <%= form.rich_text_area :content %>

    <%= form.button %>
  <% end %>
</section>
```

![A form collecting information about a Document, including its access level and content](https://user-images.githubusercontent.com/2575027/150657727-09919557-322c-4697-b529-0703b418c470.png)

When the submission's data is invalid the controller responds with a [422
Unprocessable Entity][422] re-renders the `app/views/documents/new.html.erb`
template to include the `app/views/application/_errors.html.erb` partial. That
partial's [source code](./app/views/application/_errors.html.erb) is omitted
here, but it's very similar to [Rails' scaffolds for new models][scaffolds]:

[422]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422
[scaffolds]: https://github.com/rails/rails/blob/984c3ef2775781d47efa9f541ce570daa2434a80/railties/lib/rails/generators/erb/scaffold/templates/_form.html.erb.tt#L2-L12

![Validation error messages rendered above the form's fields](https://user-images.githubusercontent.com/2575027/150657724-98d59bc0-4eda-4f75-bc83-3e2f587e3ec8.png)

When the submission is valid, the record is created, the data is written to the
database, and the controller serves an [HTTP redirect response][redirect] to the
`documents#show` route.

[redirect]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections
